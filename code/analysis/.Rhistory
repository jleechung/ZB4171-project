library(dbscan)
library(igraph)
library(leidenAlg)
library(plyr)
library(schelpers)
library(uwot)
library(ggplot2)
library(pals)
getGraph <- function(x, k) {
snet <- sNN(kNN(x, k = k), k = k)
from <- shared <- .N <- NULL
snet.dt = data.table(from = rep(1:nrow(snet$id), k),
to = as.vector(snet$id),
weight = 1/(1 + as.vector(snet$dist)),
distance = as.vector(snet$dist),
shared = as.vector(snet$shared))
data.table::setorder(snet.dt, from, -shared)
snet.dt[, rank := 1:.N, by = from]
snet.dt <- snet.dt[rank <= 3 | shared >= 5]
graph <- graph_from_data_frame(snet.dt)
return(graph)
}
runLeiden <- function(x, resolution, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
theme_blank <- function(legend.text.size,
main.size,
legend.pos) {
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
plot.background = element_blank(),
strip.background = element_blank(),
plot.title = element_text(size = main.size),
legend.text = element_text(size = legend.text.size),
legend.title = element_blank(),
legend.position = legend.pos,
legend.key = element_blank())
}
getDiscretePalette <- function(feature, col.discrete) {
num <- is.numeric(feature)
char <- is.character(feature)
if (num) n <- max(feature)
if (char) n <- length(unique(feature))
if (is.null(col.discrete)) {
pal <- getPalette(n)
if (num) pal <- pal[sort(unique(feature))]
} else {
if (length(col.discrete) < n) stop('Not enough colors')
}
return(pal)
}
getPalette <- function(n) {
all.cols <- c(pals::kelly()[-c(1,3)],
pals::glasbey(),
pals::polychrome())
all.cols <- as.character(all.cols)
return(all.cols[seq_len(n)])
}
plotReduction <- function(latent, reduction, components = c(1,2),
by = NULL, type = c('discrete', 'continuous'),
pt.size = 0.5, pt.alpha = 0.7, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
message('Computing reduction')
if (reduction == 'pca') {
data <- data.frame(prcomp(latent)$x[,1:2])
colnames(data) <- c('PC1', 'PC2')
}
if (reduction == 'umap') {
data <- data.frame(umap(latent, n_neighbors = n.neighbors,
spread = spread, min_dist = min.dist))
colnames(data) <- c('UMAP1', 'UMAP2')
}
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
plotReduction(latent, reduction = 'pca', by = mdata$Cell_class)
plotReduction(latent, reduction = 'pca', by = mdata$Cell_class, type = 'discrete')
runLeiden <- function(latent, resolution, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
clusters <- runLeiden(latent)
runLeiden <- function(latent, res=0.6, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
runLeiden <- function(latent, res=0.8, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
##### Libs and functions -------------------------------------------------------
library(data.table)
library(dbscan)
library(igraph)
library(leidenAlg)
library(plyr)
library(schelpers)
library(uwot)
library(ggplot2)
library(pals)
getGraph <- function(x, k) {
snet <- sNN(kNN(x, k = k), k = k)
from <- shared <- .N <- NULL
snet.dt = data.table(from = rep(1:nrow(snet$id), k),
to = as.vector(snet$id),
weight = 1/(1 + as.vector(snet$dist)),
distance = as.vector(snet$dist),
shared = as.vector(snet$shared))
data.table::setorder(snet.dt, from, -shared)
snet.dt[, rank := 1:.N, by = from]
snet.dt <- snet.dt[rank <= 3 | shared >= 5]
graph <- graph_from_data_frame(snet.dt)
return(graph)
}
runLeiden <- function(latent, res=0.8, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
theme_blank <- function(legend.text.size,
main.size,
legend.pos) {
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
plot.background = element_blank(),
strip.background = element_blank(),
plot.title = element_text(size = main.size),
legend.text = element_text(size = legend.text.size),
legend.title = element_blank(),
legend.position = legend.pos,
legend.key = element_blank())
}
getDiscretePalette <- function(feature, col.discrete) {
num <- is.numeric(feature)
char <- is.character(feature)
if (num) n <- max(feature)
if (char) n <- length(unique(feature))
if (is.null(col.discrete)) {
pal <- getPalette(n)
if (num) pal <- pal[sort(unique(feature))]
} else {
if (length(col.discrete) < n) stop('Not enough colors')
}
return(pal)
}
getPalette <- function(n) {
all.cols <- c(pals::kelly()[-c(1,3)],
pals::glasbey(),
pals::polychrome())
all.cols <- as.character(all.cols)
return(all.cols[seq_len(n)])
}
##### Run ----------------------------------------------------------------------
latent <- fread('../checkpoints/nbvae_1/latent.csv', header=FALSE)
locs <- fread('../data/merfish/hypo_ani1_cellcentroids.csv', header=TRUE)
mdata <- fread('../data/merfish/hypo_ani1_metadata.csv', header=TRUE)
clusters <- runLeiden(latent)
plotReduction <- function(latent, reduction, components = c(1,2),
by = NULL, type = c('discrete', 'continuous'),
pt.size = 0.5, pt.alpha = 0.7, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
message('Computing reduction')
if (reduction == 'pca') {
data <- data.frame(prcomp(latent)$x[,1:2])
colnames(data) <- c('PC1', 'PC2')
}
if (reduction == 'umap') {
data <- data.frame(umap(latent, n_neighbors = n.neighbors,
spread = spread, min_dist = min.dist))
colnames(data) <- c('UMAP1', 'UMAP2')
}
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
plotReduction(latent, reduction = 'pca', by = , type = 'discrete')
plotReduction(latent, reduction = 'pca', by = clusters, type = 'discrete')
plotReduction(latent, reduction = 'umap', by = clusters, type = 'discrete')
p1 <- plotReduction(latent, reduction = 'umap', by = clusters, type = 'discrete')
p2 <- plotReduction(latent, reduction = 'umap', by = mdata$Cell_class, type = 'discrete')
library(gridExtra)
grid.arrange(p1, p2, ncol=2)
##### Libs and functions -------------------------------------------------------
library(data.table)
library(dbscan)
library(igraph)
library(leidenAlg)
library(plyr)
library(schelpers)
library(uwot)
library(ggplot2)
library(pals)
library(gridExtra)
getGraph <- function(x, k) {
snet <- sNN(kNN(x, k = k), k = k)
from <- shared <- .N <- NULL
snet.dt = data.table(from = rep(1:nrow(snet$id), k),
to = as.vector(snet$id),
weight = 1/(1 + as.vector(snet$dist)),
distance = as.vector(snet$dist),
shared = as.vector(snet$shared))
data.table::setorder(snet.dt, from, -shared)
snet.dt[, rank := 1:.N, by = from]
snet.dt <- snet.dt[rank <= 3 | shared >= 5]
graph <- graph_from_data_frame(snet.dt)
return(graph)
}
runLeiden <- function(latent, res=0.8, k=20) {
graph <- getGraph(latent, k=k)
out <- as.numeric(leiden.community(graph, resolution = res, n.iterations = -1)$membership)
return(out)
}
theme_blank <- function(legend.text.size,
main.size,
legend.pos) {
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
plot.background = element_blank(),
strip.background = element_blank(),
plot.title = element_text(size = main.size),
legend.text = element_text(size = legend.text.size),
legend.title = element_blank(),
legend.position = legend.pos,
legend.key = element_blank())
}
getDiscretePalette <- function(feature, col.discrete) {
num <- is.numeric(feature)
char <- is.character(feature)
if (num) n <- max(feature)
if (char) n <- length(unique(feature))
if (is.null(col.discrete)) {
pal <- getPalette(n)
if (num) pal <- pal[sort(unique(feature))]
} else {
if (length(col.discrete) < n) stop('Not enough colors')
}
return(pal)
}
getPalette <- function(n) {
all.cols <- c(pals::kelly()[-c(1,3)],
pals::glasbey(),
pals::polychrome())
all.cols <- as.character(all.cols)
return(all.cols[seq_len(n)])
}
runPCA <- function(latent) {
data <- data.frame(prcomp(latent)$x[,1:2])
colnames(data) <- c('PC1', 'PC2')
return(data)
}
runUMAP <- function(latent, n.neighbors=30, spread=2, min.dist=0.1) {
data <- data.frame(umap(latent, n_neighbors = n.neighbors,
spread = spread, min_dist = min.dist))
colnames(data) <- c('UMAP1', 'UMAP2')
return(data)
}
plotMain <- function(latent, coordinates,
by = NULL, type = c('discrete', 'continuous'),
pt.size = 0.5, pt.alpha = 0.7, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
data <- coordinates
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
##### Run ----------------------------------------------------------------------
latent <- fread('../checkpoints/nbvae_1/latent.csv', header=FALSE)
locs <- fread('../data/merfish/hypo_ani1_cellcentroids.csv', header=TRUE)
mdata <- fread('../data/merfish/hypo_ani1_metadata.csv', header=TRUE)
clusters <- runLeiden(latent)
celltype <- mdata$Cell_class
pca.coords <- runPCA(latent)
umap.coords <- runUMAP(latent)
pca.coords
umap.coords
plotMain <- function(coordinates,
by = NULL, type = c('discrete', 'continuous'),
pt.size = 0.5, pt.alpha = 0.7, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
data <- coordinates
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
plotMain(pca.coords)
plotMain(pca.coords, by = clusters)
plotMain(pca.coords, by = clusters, type = 'discrete')
plotMain <- function(coordinates,
by = NULL, type = 'discrete',
pt.size = 0.5, pt.alpha = 0.7, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
data <- coordinates
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
plotMain(pca.coords, by = clusters)
plotMain(pca.coords, by = celltype)
u1 <- plotMain(umap.coords, by = clusters)
u2 <- plotMain(umap.coords, by = celltype)
grid.arrange(u1, u2, ncol = 2)
grid.arrange(u1, u2, ncol = 2)
plotMain <- function(coordinates,
by = NULL, type = 'discrete',
pt.size = 0.5, pt.alpha = 0.9, col.midpoint = NULL, col.low = 'blue',
col.mid = 'gray95', col.high = 'red', col.discrete = NULL, main = NULL,
main.size = 5, legend = TRUE, legend.text.size = 6, legend.pt.size = 3,
n.neighbors = 30, spread = 2, min.dist = 0.1) {
data <- coordinates
x <- colnames(data)[1]
y <- colnames(data)[2]
if (is.null(by)) plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y)))
else {
feature <- by
if (type == 'continuous') {
if (is.null(col.midpoint)) col.midpoint <- median(feature)
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = feature)) +
scale_color_gradient2(midpoint = col.midpoint, low = col.low,
mid = col.mid, high = col.high)
}
if (type == 'discrete') {
plot <- ggplot(data, aes(x = !!ensym(x), y = !!ensym(y), col = as.factor(feature))) +
scale_color_manual(values = getDiscretePalette(feature, col.discrete)) +
guides(color = guide_legend(override.aes = list(size = legend.pt.size)))
}
}
legend.pos <- ifelse(legend, 'right', 'none')
plot <- plot + geom_point(size = pt.size, alpha = pt.alpha) + ggtitle(main) +
theme_blank(legend.text.size = legend.text.size,
main.size = main.size,
legend.pos = legend.pos)
return(plot)
}
u1 <- plotMain(umap.coords, by = clusters)
u2 <- plotMain(umap.coords, by = celltype)
grid.arrange(u1, u2, ncol = 2)
grid.arrange(u1, u2, ncol = 2)
sp1 <- plotMain(locs, by = clusters)
sp2 <- plotMain(locs, by = celltype)
grid.arrange(sp1, sp2, ncol = 2)
sp1 <- plotMain(locs, by = clusters, pt.size = 1)
sp2 <- plotMain(locs, by = celltype, pt.size = 1)
grid.arrange(sp1, sp2, ncol = 2)
mapToSeed <- function(val, seed) {
con.mat <- table(val, seed)
cost.mat <- max(con.mat) - con.mat
matching <- HungarianSolver(cost.mat)$pairs
## Mapping fr more clusters to fewer
unmapped <- which(matching[,2] == 0)
impute <- max(seed) + seq_len(length(unmapped))
matching[,2][matching[,2] == 0] <- impute
new.val <- mapvalues(x = val, from = matching[,1], to = matching[,2])
return(new.val)
}
mapToSeed(clusters, celltype)
library(plyr)
library(pals)
library(plyr)
library(uwot)
library(dbscan)
library(igraph)
library(ggplot2)
library(schelpers)
library(gridExtra)
library(leidenAlg)
library(data.table)
library(RcppHungarian)
mapToSeed(clusters, celltype)
mapToSeed <- function(val, seed) {
con.mat <- table(val, seed)
cost.mat <- max(con.mat) - con.mat
matching <- HungarianSolver(cost.mat)$pairs
## Mapping fr more clusters to fewer
unmapped <- which(matching[,2] == 0)
if (is.character(seed)) start <- length(unique(seed))
if (is.numeric(seed)) start <- max(seed)
impute <- start + seq_len(length(unmapped))
matching[,2][matching[,2] == 0] <- impute
new.val <- mapvalues(x = val, from = matching[,1], to = matching[,2])
return(new.val)
}
mapToSeed(clusters, celltype)
clusters.mapped <- mapToSeed(clusters, celltype)
table(clusters.mapped, clusters)
sp1 <- plotMain(locs, by = clusters.mapped, pt.size = 1)
sp2 <- plotMain(locs, by = celltype, pt.size = 1)
grid.arrange(sp1, sp2, ncol = 2)
